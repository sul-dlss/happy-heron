#!/usr/bin/env ruby
# frozen_string_literal: true

# Usage:
#   RAILS_ENV=production bin/migrate-collections collections.jsonl 2>&1 | tee -a migrate-collections.log

require_relative '../config/environment'

STATES = {
  'published_open' => 'deposited',
  'published_closed' => 'deposited',
  'draft' => 'first_draft'
}

RELEASE_OPTION = {
  'varies' => 'depositor-selects',
  'none' => 'immediate',
  'fixed' => 'delay'
}

LICENSE_OPTION = {
  'varies' => 'depositor-selects',
  'none' => 'immediate',
  'fixed' => 'required'
}

LICENSE = {
  'cc-by' => 'CC-BY-3.0',
  'cc-by-nc' => 'CC-BY-NC-3.0',
  'cc-by-nc-nd' => 'CC-BY-NC-ND-3.0',
  'cc-by-nc-sa' => 'CC-BY-NC-SA-3.0',
  'cc-by-nd' => 'CC-BY-ND-3.0',
  'cc-by-sa' => 'CC-BY-SA-3.0',
  'none' => 'none',
  'odc-by' => 'ODC-By-1.0',
  'odc-odbl' => 'ODbL-1.0',
  'pddl' => 'PDDL-1.0'
}

def contact_emails(json)
  json['contact_email'].split(', ').map do |email|
    if URI::MailTo::EMAIL_REGEXP.match(email)
      ContactEmail.create(email: email)
    elsif email.present?
      warn "Invalid contact email found in #{json['druid']}: #{email}"
      nil
    end
  end.compact
end

def release_attributes(json)
  data = case json.fetch('visibility_option')
         when 'varies'
           { access: 'depositor-selects' }
         when 'fixed'
           { access: json.fetch('visibility').first }
         else
           warn "unexpected collection visibility option: #{json.fetch('visibility_option').inspect}"
           {}
         end

  release_option = RELEASE_OPTION.fetch(json.fetch('embargo_option'))
  data[:release_option] = release_option

  return data unless release_option == 'depositor-selects'

  data.merge(release_duration: json.fetch('embargo_terms'))
end

def add_events!(collection, json)
  json.fetch('events').each do |event|
    collection.events.build(
        user: User.find_or_create_by!(email: "#{event['who'].downcase}@stanford.edu"),
        created_at: Time.parse(event['when']),
        updated_at: Time.parse(event['when']),
        event_type: 'update_metadata', # is this OK?
        description: event['text']
      )
  end
end

def license_attributes(json)
  license_option = LICENSE_OPTION.fetch(json.fetch('license_option'))
  license = LICENSE.fetch(json.fetch('license'))

  data = {
    license_option: license_option
  }

  case license_option
  when 'required'
    data[:required_license] = license
  when 'depositor-selects'
    data[:default_license] = license
  end

  data
end

def participants_attributes(json)
  managers = json['managers'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  depositors = json['depositors'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  reviewers = json['reviewers'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  {
    managed_by: managers,
    depositors: depositors,
    reviewed_by: reviewers
  }
end

def build_collection_attributes(json)
  {
    creator: User.find_or_create_by!(email: "#{json.dig('creator', 'sunetid')}@stanford.edu"),
    created_at: Time.parse(json['created_at']),
    updated_at: Time.parse(json['updated_at'])
  }.merge(release_attributes(json)).
    merge(license_attributes(json)).
    merge(participants_attributes(json))
end

def build_collection_version_attributes(json)
  {
    version: json.fetch('version'),
    state: STATES.fetch(json.fetch('object_status')),
    name: json.fetch('name'),
    description: json.fetch('description'),
    created_at: Time.parse(json['created_at']),
    updated_at: Time.parse(json['updated_at']),
    contact_emails: contact_emails(json),
    related_links: json.fetch('related_items').reject { |item| item['url'].blank? }.map { |item| RelatedLink.new(item) },
  }
end

File.foreach(ARGV[0]) do |data|
  puts "STARTING NEW COLLECTION MIGRATION: #{Time.now}"
  puts
  json = JSON.parse(data)
  next unless json.present?
  collection = Collection.find_or_initialize_by(druid: json['druid'])
  collection_attributes = build_collection_attributes(json)
  collection_version = CollectionVersion.find_or_initialize_by(collection: collection)
  collection_version_attributes = build_collection_version_attributes(json)
  add_events!(collection, json)

  if collection_attributes.blank?
    warn "attrs blank for collection #{json['druid']}: #{collection_attributes.inspect}"
    next
  end

  if collection_version_attributes.blank?
    warn "attrs blank for collection version #{json['druid']} version: #{collection_version_attributes}"
    next
  end

  begin
    collection_update_successful = collection.update(collection_attributes)
    collection_version_update_successful = collection_version.update(collection_version_attributes)
    collection.update(head: collection_version)

    if collection_update_successful && collection_version_update_successful
      puts "Collection #{collection.id} (v#{collection_version.version}): #{collection.druid}"
    else
      warn "Validation failed on #{json['druid']}, #{collection.errors.full_messages} #{collection_version.errors.full_messages}"
    end
  rescue ActiveRecord::RecordNotSaved => e
    warn "unable to save #{json['druid']}: #{e}"
  end
  puts
end
