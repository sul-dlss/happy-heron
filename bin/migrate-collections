#!/usr/bin/env ruby
# frozen_string_literal: true

# Usage:
#   bin/migrate-collections collections.jsonl

require_relative '../config/environment'

Rails.logger.level = :warn

STATES = {
  'published_open' => 'deposited',
  'published_closed' => 'deposited',
  'draft' => 'first_draft'
}.freeze

RELEASE_OPTION = {
  'varies' => 'depositor-selects',
  'fixed' => 'delay',
  'none' => 'immediate'
}.freeze

def contact_emails(json)
  json['contact_email'].split(/,\s*/).map { |email| contact_email(email, json['druid']) }.compact
end

def contact_email(email, druid)
  if URI::MailTo::EMAIL_REGEXP.match(email)
    ContactEmail.new(email: email)
  elsif email.present?
    warn "Invalid contact email found in #{druid}: #{email}"
    nil
  end
end

def release_attributes(json)
  access = if json.fetch('visibility_option') == 'fixed'
             json.fetch('visibility').first
           else
             'depositor-selects'
           end
  data = {
    access: access,
    release_option: RELEASE_OPTION.fetch(json.fetch('embargo_option'))
  }

  return data if data[:release_option] == 'immediate'

  data.merge(release_duration: json.fetch('embargo_terms'))
end

def license_attributes(json)
  case json.fetch('license_option')
  when 'none'
    {
      license_option: 'required',
      required_license: 'none'
    }
  when 'fixed'
    {
      license_option: 'required',
      required_license: h2_license_code(json.fetch('license'))
    }
  else
    {
      license_option: 'depositor-selects',
      default_license: h2_license_code(json.fetch('license'))
    }
  end
end

def h2_license_code(hydrus_license)
  return "#{hydrus_license.upcase}-3.0" if hydrus_license.start_with?('cc-')

  case hydrus_license
  when 'odc-odbl'
    'ODbL-1.0'
  when 'odc-by'
    'ODC-By-1.0'
  when 'pddl'
    'PDDL-1.0'
  when 'none'
    'none'
  else
    raise "Unrecognized license #{hydrus_license}"
  end
end

def participants_attributes(json)
  managers = json['managers'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  depositors = json['depositors'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  reviewers = json['reviewers'].map do |sunetid|
    User.find_or_create_by!(email: "#{sunetid.downcase}@stanford.edu")
  end
  {
    managed_by: managers,
    depositors: depositors,
    reviewed_by: reviewers
  }
end

def build_collection_attributes(json)
  creator = User.find_or_create_by!(email: "#{json.dig('creator', 'sunetid')}@stanford.edu")

  {
    review_enabled: json.fetch('requires_human_approval') == 'yes',
    creator: creator
  }.merge(release_attributes(json))
    .merge(license_attributes(json))
    .merge(participants_attributes(json))
end

def build_collection_version_attributes(json)
  {
    version: json.fetch('version'),
    description: json.fetch('description'),
    contact_emails: contact_emails(json),
    name: json.fetch('name'),
    state: STATES.fetch(json.fetch('object_status')),
    related_links: json.fetch('related_items').reject { |item| item['url'].blank? }.map { |item| RelatedLink.new(item) }
  }
end

File.foreach(ARGV[0]) do |data|
  json = JSON.parse(data)
  next if json.blank?

  collection = Collection.find_by(druid: json['druid'])
  if collection
    collection.update!(build_collection_attributes(json))
  else
    collection = Collection.new(build_collection_attributes(json).merge(druid: json['druid']))
    collection.save!
  end

  collection_version = collection.head
  if collection_version
    collection_version.update!(build_collection_version_attributes(json))
  else
    collection_version = collection.build_head(build_collection_version_attributes(json)
      .merge(collection_id: collection.id, version: json.fetch('version')))
    collection_version.save!
    collection.update!(head: collection_version)
  end

  puts "collection #{collection.id}"
end
