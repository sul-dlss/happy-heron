# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/bunny/all/bunny.rbi
#
# bunny-2.19.0

module Bunny
  def self.new(connection_string_or_opts = nil, opts = nil); end
  def self.protocol_version; end
  def self.run(connection_string_or_opts = nil, opts = nil, &block); end
  def self.version; end
end
module AMQ
end
module AMQ::Protocol
end
class AMQ::Protocol::Basic < AMQ::Protocol::Class
end
class AMQ::Protocol::Basic::GetOk < AMQ::Protocol::Method
  def delivery_tag=(arg0); end
end
module Bunny::Framing
end
module Bunny::Framing::String
end
class Bunny::Framing::String::Frame < AMQ::Protocol::Frame
  def self.decode(string); end
end
module Bunny::Framing::IO
end
class Bunny::Framing::IO::Frame < AMQ::Protocol::Frame
  def self.decode(io); end
end
class Bunny::Exception < StandardError
end
class Bunny::HostListDepleted < Bunny::Exception
  def initialize; end
end
class Bunny::NetworkFailure < Bunny::Exception
  def cause; end
  def initialize(message, cause); end
end
class Bunny::ChannelLevelException < Bunny::Exception
  def channel; end
  def channel_close; end
  def initialize(message, ch, channel_close); end
end
class Bunny::ConnectionLevelException < Bunny::Exception
  def connection; end
  def connection_close; end
  def initialize(message, connection, connection_close); end
end
class Bunny::NotAllowedError < Bunny::Exception
  def connection; end
  def connection_close; end
  def initialize(message, connection, connection_close = nil); end
end
class Bunny::TCPConnectionFailed < Bunny::Exception
  def hostname; end
  def initialize(e, hostname = nil, port = nil); end
  def port; end
end
class Bunny::TCPConnectionFailedForAllHosts < Bunny::TCPConnectionFailed
  def initialize; end
end
class Bunny::ConnectionClosedError < Bunny::Exception
  def initialize(frame); end
end
class Bunny::ConnectionAlreadyClosed < Bunny::Exception
  def initialize; end
end
class Bunny::ShutdownSignal < Bunny::Exception
end
class Bunny::PossibleAuthenticationFailureError < Bunny::Exception
  def initialize(username, vhost, password_length); end
  def username; end
  def vhost; end
end
class Bunny::AuthenticationFailureError < Bunny::PossibleAuthenticationFailureError
  def initialize(username, vhost, password_length); end
  def username; end
  def vhost; end
end
class Bunny::ForcedChannelCloseError < Bunny::ChannelLevelException
end
class Bunny::ForcedConnectionCloseError < Bunny::ConnectionLevelException
end
class Bunny::MessageError < Bunny::ConnectionLevelException
end
class Bunny::ProtocolError < Bunny::ConnectionLevelException
end
class Bunny::InternalError < Bunny::ConnectionLevelException
end
class Bunny::ClientTimeout < Timeout::Error
end
class Bunny::ConnectionTimeout < Timeout::Error
end
class Bunny::InconsistentDataError < Bunny::Exception
end
class Bunny::NoFinalOctetError < Bunny::InconsistentDataError
  def initialize; end
end
class Bunny::BadLengthError < Bunny::InconsistentDataError
  def initialize(expected_length, actual_length); end
end
class Bunny::ChannelAlreadyClosed < Bunny::Exception
  def channel; end
  def initialize(message, ch); end
end
class Bunny::PreconditionFailed < Bunny::ChannelLevelException
end
class Bunny::NotFound < Bunny::ChannelLevelException
end
class Bunny::ResourceLocked < Bunny::ChannelLevelException
end
class Bunny::AccessRefused < Bunny::ChannelLevelException
end
class Bunny::ChannelError < Bunny::ConnectionLevelException
end
class Bunny::CommandInvalid < Bunny::ConnectionLevelException
end
class Bunny::FrameError < Bunny::ConnectionLevelException
end
class Bunny::UnexpectedFrame < Bunny::ConnectionLevelException
end
class Bunny::ResourceError < Bunny::ConnectionLevelException
end
class Bunny::NetworkErrorWrapper < Bunny::Exception
  def initialize(other); end
  def other; end
end
class Bunny::ConnectionForced < Bunny::ConnectionLevelException
end
class Bunny::MissingTLSCertificateFile < Bunny::Exception
end
class Bunny::MissingTLSKeyFile < Bunny::Exception
end
module Bunny::Socket
  def options; end
  def options=(arg0); end
  def read_fully(count, timeout = nil); end
  def self.open(host, port, options = nil); end
  def write_nonblock_fully(data, timeout = nil); end
end
class Bunny::SSLSocket < OpenSSL::SSL::SSLSocket
  def initialize(*args); end
  def read_fully(count, timeout = nil); end
  def write_nonblock_fully(data, timeout = nil); end
end
class Bunny::Transport
  def as_boolean(val); end
  def check_local_certificate_path!(s); end
  def check_local_key_path!(s); end
  def close(reason = nil); end
  def closed?; end
  def configure_socket(&block); end
  def configure_tls_context(&block); end
  def connect; end
  def connect_timeout; end
  def connected?; end
  def disconnect_timeout; end
  def flush; end
  def host; end
  def hostname; end
  def initialize(session, host, port, opts); end
  def initialize_socket; end
  def initialize_tls_certificate_store(certs); end
  def initialize_tls_context(ctx, opts = nil); end
  def inline_client_certificate_from(opts); end
  def inline_client_key_from(opts); end
  def local_address; end
  def log_peer_certificate_chain_info(severity, chain); end
  def log_peer_certificate_info(severity, peer_cert, prefix = nil); end
  def maybe_initialize_socket; end
  def open?; end
  def peer_certificate_info(peer_cert, prefix = nil); end
  def port; end
  def post_initialize_socket; end
  def prepare_tls_context(opts); end
  def read_client_certificate!; end
  def read_client_key!; end
  def read_fully(count); end
  def read_next_frame(opts = nil); end
  def read_ready?(timeout = nil); end
  def read_timeout; end
  def read_timeout=(v); end
  def self.ping!(host, port, timeout); end
  def self.reacheable?(host, port, timeout); end
  def send_frame(frame); end
  def send_frame_without_timeout(frame); end
  def session; end
  def socket; end
  def ssl?; end
  def timeout_from(options); end
  def tls?; end
  def tls_ca_certificates; end
  def tls_ca_certificates_paths_from(opts); end
  def tls_certificate_from(opts); end
  def tls_certificate_path; end
  def tls_certificate_path_from(opts); end
  def tls_context; end
  def tls_enabled?(opts); end
  def tls_key_from(opts); end
  def tls_key_path; end
  def tls_key_path_from(opts); end
  def uses_ssl?; end
  def uses_tls?; end
  def verify_peer; end
  def wrap_in_tls_socket(socket); end
  def write(data); end
  def write_timeout; end
  def write_without_timeout(data, raise_exceptions = nil); end
end
class Bunny::ChannelIdAllocator
  def allocated_channel_id?(i); end
  def initialize(max_channel = nil); end
  def next_channel_id; end
  def release_channel_id(i); end
  def reset_channel_id_allocator; end
  def synchronize(&block); end
end
class Bunny::HeartbeatSender
  def beat; end
  def initialize(transport, logger); end
  def run; end
  def signal_activity!; end
  def start(period = nil); end
  def stop; end
end
class Bunny::ReaderLoop
  def initialize(transport, session, session_error_handler); end
  def io_error?(e); end
  def join; end
  def kill; end
  def log_exception(e, level: nil); end
  def raise(e); end
  def resume; end
  def run_loop; end
  def run_once; end
  def start; end
  def stop; end
  def stopped?; end
  def stopping?; end
  def terminate?; end
  def terminate_with(e); end
end
module Bunny::Authentication
end
class Bunny::Authentication::CredentialsEncoder
  def encode_credentials(username, challenge); end
  def initialize(session); end
  def self.auth_mechanism(*mechanisms); end
  def self.for_session(session); end
  def self.registry; end
  def session; end
end
class Bunny::Authentication::PlainMechanismEncoder < Bunny::Authentication::CredentialsEncoder
  def encode_credentials(username, password); end
end
class Bunny::Authentication::ExternalMechanismEncoder < Bunny::Authentication::CredentialsEncoder
  def encode_credentials(username, password); end
end
module Bunny::Concurrent
end
class Bunny::Concurrent::ContinuationQueue
  def <<(item); end
  def clear; end
  def empty?; end
  def initialize; end
  def length; end
  def poll(timeout_in_ms = nil); end
  def pop; end
  def push(item); end
  def size; end
end
class Bunny::Session
  def addresses_from(options); end
  def after_recovery_completed(&block); end
  def announce_network_failure_recovery; end
  def automatically_recover?; end
  def before_recovery_attempt_starts(&block); end
  def blocked?; end
  def channel(n = nil, consumer_pool_size = nil, consumer_pool_abort_on_exception = nil, consumer_pool_shutdown_timeout = nil); end
  def channel_id_allocator; end
  def channel_max; end
  def clean_up_and_fail_on_connection_close!(method); end
  def clean_up_on_shutdown; end
  def close(await_response = nil); end
  def close_all_channels; end
  def close_channel(ch); end
  def close_connection(await_response = nil); end
  def close_transport; end
  def closed?; end
  def closing?; end
  def configure_socket(&block); end
  def connected?; end
  def connecting?; end
  def connection_name; end
  def continuation_timeout; end
  def create_channel(n = nil, consumer_pool_size = nil, consumer_pool_abort_on_exception = nil, consumer_pool_shutdown_timeout = nil); end
  def credentials_encoder_for(mechanism); end
  def decrement_recovery_attemp_counter!; end
  def encode_credentials(username, password); end
  def exchange_exists?(name); end
  def find_channel(number); end
  def frame_max; end
  def handle_frame(ch_number, method); end
  def handle_frameset(ch_number, frames); end
  def handle_network_failure(exception); end
  def heartbeat; end
  def heartbeat_disabled?(val); end
  def heartbeat_from(options); end
  def heartbeat_interval; end
  def heartbeat_timeout; end
  def host; end
  def host_from_address(address); end
  def host_with_port?(address); end
  def hostname; end
  def ignoring_io_errors(&block); end
  def init_connection; end
  def init_default_logger(logfile, level); end
  def init_default_logger_without_progname(logfile, level); end
  def initialize(connection_string_or_opts = nil, optz = nil); end
  def initialize_heartbeat_sender; end
  def initialize_transport; end
  def inspect; end
  def instantiate_connection_level_exception(frame); end
  def local_port; end
  def logger; end
  def manually_closed?; end
  def maybe_close_transport; end
  def maybe_shutdown_heartbeat_sender; end
  def maybe_shutdown_reader_loop; end
  def mechanism; end
  def mutex_impl; end
  def negotiate_value(client_value, server_value); end
  def network_recovery_interval; end
  def next_channel_id; end
  def normalize_auth_mechanism(value); end
  def normalize_client_channel_max(n); end
  def normalize_log_level(level); end
  def notify_of_recovery_attempt_start; end
  def notify_of_recovery_completion; end
  def on_blocked(&block); end
  def on_unblocked(&block); end
  def open?; end
  def open_channel(ch); end
  def open_connection; end
  def pass; end
  def password; end
  def password_from(options); end
  def port; end
  def port_from(options); end
  def port_from_address(address); end
  def queue_exists?(name); end
  def raise_if_continuation_resulted_in_a_connection_error!; end
  def reader_loop; end
  def recover_channels; end
  def recover_from_connection_close?; end
  def recover_from_network_failure; end
  def recoverable_network_failure?(exception); end
  def recovering_from_network_failure?; end
  def recovery_attempts_limited?; end
  def register_channel(ch); end
  def release_channel_id(i); end
  def reset_address_index; end
  def reset_continuations; end
  def reset_recovery_attempt_counter!; end
  def self.parse_uri(uri); end
  def send_frame(frame, signal_activity = nil); end
  def send_frame_without_timeout(frame, signal_activity = nil); end
  def send_frameset(frames, channel); end
  def send_frameset_without_timeout(frames, channel); end
  def send_preamble; end
  def send_raw_without_timeout(data, channel); end
  def server_authentication_mechanisms; end
  def server_capabilities; end
  def server_locales; end
  def server_properties; end
  def should_retry_recovery?; end
  def shut_down_all_consumer_work_pools!; end
  def signal_activity!; end
  def socket_configurator; end
  def socket_configurator=(arg0); end
  def ssl?; end
  def start; end
  def start_reader_loop; end
  def status; end
  def stop(await_response = nil); end
  def synchronised_find_channel(number); end
  def threaded; end
  def threaded?; end
  def tls?; end
  def to_s; end
  def transport; end
  def transport_write_timeout; end
  def unregister_channel(ch); end
  def update_secret(value, reason); end
  def user; end
  def username; end
  def username_from(options); end
  def uses_ssl?; end
  def uses_tls?; end
  def validate_connection_options(options); end
  def vhost; end
  def vhost_from(options); end
  def virtual_host; end
  def wait_on_continuations; end
  def with_channel(n = nil); end
end
class Bunny::Concurrent::AtomicFixnum
  def ==(m); end
  def ===(v); end
  def dec; end
  def decrement; end
  def decrement_and_get; end
  def get; end
  def get_and_add(i); end
  def get_and_increment; end
  def inc; end
  def increment; end
  def increment_and_get; end
  def initialize(n = nil); end
  def set(n); end
  def to_i; end
end
class Bunny::ConsumerWorkPool
  def abort_on_exception; end
  def backlog; end
  def busy?; end
  def initialize(size = nil, abort_on_exception = nil, shutdown_timeout = nil); end
  def join(timeout = nil); end
  def kill; end
  def pause; end
  def resume; end
  def run_loop; end
  def running?; end
  def shutdown(wait_for_workers = nil); end
  def size; end
  def start; end
  def submit(callable = nil, &block); end
  def threads; end
end
class Bunny::Exchange
  def arguments; end
  def auto_delete?; end
  def bind(source, opts = nil); end
  def channel; end
  def declare!; end
  def delete(opts = nil); end
  def durable?; end
  def handle_return(basic_return, properties, content); end
  def initialize(channel, type, name, opts = nil); end
  def internal?; end
  def name; end
  def on_return(&block); end
  def opts; end
  def opts=(arg0); end
  def predeclared?; end
  def predefined?; end
  def publish(payload, opts = nil); end
  def recover_from_network_failure; end
  def self.add_default_options(name, opts); end
  def self.default(channel_or_connection); end
  def status; end
  def type; end
  def unbind(source, opts = nil); end
  def wait_for_confirms; end
end
class Bunny::VersionedDeliveryTag
  def initialize(tag, version); end
  def stale?(version); end
  def tag; end
  def to_i; end
  def version; end
end
class Bunny::GetResponse
  def [](k); end
  def channel; end
  def delivery_tag; end
  def each(*args, &block); end
  def exchange; end
  def initialize(get_ok, channel); end
  def inspect; end
  def redelivered; end
  def redelivered?; end
  def routing_key; end
  def to_hash; end
  def to_s; end
  include Enumerable
end
class Bunny::Queue
  def arguments; end
  def auto_delete?; end
  def bind(exchange, opts = nil); end
  def channel; end
  def consumer_count; end
  def declare!; end
  def delete(opts = nil); end
  def durable?; end
  def exclusive?; end
  def get(opts = nil, &block); end
  def initialize(channel, name = nil, opts = nil); end
  def inspect; end
  def message_count; end
  def name; end
  def options; end
  def pop(opts = nil, &block); end
  def publish(payload, opts = nil); end
  def purge(opts = nil); end
  def recover_bindings; end
  def recover_from_network_failure; end
  def self.add_default_options(name, opts); end
  def server_named?; end
  def status; end
  def subscribe(opts = nil, &block); end
  def subscribe_with(consumer, opts = nil); end
  def to_s; end
  def unbind(exchange, opts = nil); end
end
class Bunny::DeliveryInfo
  def [](k); end
  def channel; end
  def consumer; end
  def consumer_tag; end
  def delivery_tag; end
  def each(*args, &block); end
  def exchange; end
  def initialize(basic_deliver, consumer, channel); end
  def inspect; end
  def redelivered; end
  def redelivered?; end
  def routing_key; end
  def to_hash; end
  def to_s; end
  include Enumerable
end
class Bunny::ReturnInfo
  def [](k); end
  def each(*args, &block); end
  def exchange; end
  def initialize(basic_return); end
  def inspect; end
  def reply_code; end
  def reply_text; end
  def routing_key; end
  def to_hash; end
  def to_s; end
  include Enumerable
end
class Bunny::MessageProperties
  def [](k); end
  def app_id; end
  def cluster_id; end
  def content_encoding; end
  def content_type; end
  def correlation_id; end
  def delivery_mode; end
  def each(*args, &block); end
  def expiration; end
  def headers; end
  def initialize(properties); end
  def inspect; end
  def message_id; end
  def priority; end
  def reply_to; end
  def timestamp; end
  def to_hash; end
  def to_s; end
  def type; end
  def user_id; end
  include Enumerable
end
class Bunny::Channel
  def ack(delivery_tag, multiple = nil); end
  def acknowledge(delivery_tag, multiple = nil); end
  def active; end
  def add_consumer(queue, consumer_tag, no_ack, exclusive, arguments, &block); end
  def any_consumers?; end
  def basic_ack(delivery_tag, multiple = nil); end
  def basic_cancel(consumer_tag); end
  def basic_consume(queue, consumer_tag = nil, no_ack = nil, exclusive = nil, arguments = nil, &block); end
  def basic_consume_with(consumer); end
  def basic_get(queue, opts = nil); end
  def basic_nack(delivery_tag, multiple = nil, requeue = nil); end
  def basic_publish(payload, exchange, routing_key, opts = nil); end
  def basic_qos(count, global = nil); end
  def basic_recover(requeue); end
  def basic_reject(delivery_tag, requeue = nil); end
  def can_accept_queue_declare_ok?(method); end
  def channel_flow(active); end
  def channel_level_exception_after_operation_that_has_no_response?(method); end
  def client; end
  def close; end
  def closed!; end
  def closed?; end
  def confirm_select(callback = nil); end
  def connection; end
  def consume(queue, consumer_tag = nil, no_ack = nil, exclusive = nil, arguments = nil, &block); end
  def consume_with(consumer); end
  def consumers; end
  def default_exchange; end
  def deregister_exchange(exchange); end
  def deregister_queue(queue); end
  def deregister_queue_named(name); end
  def direct(name, opts = nil); end
  def exchange(name, opts = nil); end
  def exchange_bind(source, destination, opts = nil); end
  def exchange_declare(name, type, opts = nil); end
  def exchange_delete(name, opts = nil); end
  def exchange_unbind(source, destination, opts = nil); end
  def exchanges; end
  def fanout(name, opts = nil); end
  def find_exchange(name); end
  def find_queue(name); end
  def flow(active); end
  def frame_size; end
  def generate_consumer_tag(name = nil); end
  def guarding_against_stale_delivery_tags(tag, &block); end
  def handle_ack_or_nack(delivery_tag_before_offset, multiple, nack); end
  def handle_basic_get_empty(basic_get_empty); end
  def handle_basic_get_ok(basic_get_ok, properties, content); end
  def handle_basic_return(basic_return, properties, content); end
  def handle_frameset(basic_deliver, properties, content); end
  def handle_method(method); end
  def headers(name, opts = nil); end
  def id; end
  def id=(arg0); end
  def increment_recoveries_counter; end
  def initialize(connection = nil, id = nil, work_pool = nil); end
  def inspect; end
  def instantiate_channel_level_exception(frame); end
  def maybe_kill_consumer_work_pool!; end
  def maybe_pause_consumer_work_pool!; end
  def maybe_start_consumer_work_pool!; end
  def nack(delivery_tag, multiple = nil, requeue = nil); end
  def nacked_set; end
  def new_continuation; end
  def next_publish_seq_no; end
  def number; end
  def on_error(&block); end
  def on_uncaught_exception(&block); end
  def open; end
  def open?; end
  def pending_server_named_queue_declaration?; end
  def prefetch(count, global = nil); end
  def prefetch_count; end
  def prefetch_global; end
  def queue(name = nil, opts = nil); end
  def queue_bind(name, exchange, opts = nil); end
  def queue_declare(name, opts = nil); end
  def queue_delete(name, opts = nil); end
  def queue_purge(name, opts = nil); end
  def queue_unbind(name, exchange, opts = nil); end
  def queues; end
  def raise_if_channel_close!(method); end
  def raise_if_continuation_resulted_in_a_channel_error!; end
  def raise_if_no_longer_open!; end
  def read_and_reset_only_acks_received; end
  def read_next_frame(options = nil); end
  def recover(ignored = nil); end
  def recover_cancelled_consumers!; end
  def recover_confirm_mode; end
  def recover_consumers; end
  def recover_exchanges; end
  def recover_from_network_failure; end
  def recover_prefetch_setting; end
  def recover_queues; end
  def recover_tx_mode; end
  def recoveries_counter; end
  def recovers_cancelled_consumers?; end
  def register_consumer(consumer_tag, consumer); end
  def register_exchange(exchange); end
  def register_queue(queue); end
  def reject(delivery_tag, requeue = nil); end
  def release_all_continuations; end
  def reset_continuations; end
  def status; end
  def synchronize(&block); end
  def temporary_queue(opts = nil); end
  def to_s; end
  def topic(name, opts = nil); end
  def tx_commit; end
  def tx_rollback; end
  def tx_select; end
  def unconfirmed_set; end
  def unregister_consumer(consumer_tag); end
  def using_publisher_confirmations?; end
  def using_publisher_confirms?; end
  def using_tx?; end
  def wait_for_confirms; end
  def wait_on_basic_get_continuations; end
  def wait_on_confirms_continuations; end
  def wait_on_continuations; end
  def wait_on_continuations_timeout; end
  def with_continuation_timeout(&block); end
  def work_pool; end
end
class Bunny::Consumer
  def arguments; end
  def automatic_acknowledgement?; end
  def call(*args); end
  def cancel; end
  def channel; end
  def consumer_tag; end
  def consumer_tag=(arg0); end
  def exclusive; end
  def handle_cancellation(basic_cancel); end
  def handle_delivery(*args); end
  def initialize(channel, queue, consumer_tag = nil, no_ack = nil, exclusive = nil, arguments = nil); end
  def inspect; end
  def manual_acknowledgement?; end
  def no_ack; end
  def on_cancellation(&block); end
  def on_delivery(&block); end
  def queue; end
  def queue_name; end
  def recover_from_network_failure; end
  def to_s; end
end
