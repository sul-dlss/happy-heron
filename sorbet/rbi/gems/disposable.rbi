# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/disposable/all/disposable.rbi
#
# disposable-0.4.7

module Disposable
end
module Disposable::Twin::Property
end
module Disposable::Twin::Property::Unnest
  def self.included(includer); end
  def unnest(name, options); end
end
class Disposable::Twin
  def schema; end
  def self.collection(name, options = nil, &block); end
  def self.create_accessors(name, definition); end
  def self.default_nested_class; end
  def self.definition_class; end
  def self.from_collection(collection); end
  def self.inherited(subclass); end
  def self.property(name, options = nil, &block); end
  extend Declarative::Heritage::DSL
  extend Declarative::Heritage::Inherited
  extend Declarative::Schema
  extend Declarative::Schema::DSL
  extend Declarative::Schema::Feature
  include Disposable::Twin::Accessors
  include Disposable::Twin::ModelReaders
  include Disposable::Twin::Setup
end
module Disposable::Twin::Setup
  def initialize(model, options = nil); end
  def mapper_for(model); end
  def read_value_for(dfn, options); end
  def setup_properties!(options); end
  def setup_property!(dfn, options); end
  def setup_value_for(dfn, options); end
  def setup_write!(dfn, value); end
end
module Disposable::Twin::Setup::SkipSetter
  def setup_write!(dfn, value); end
end
class Disposable::Twin::Definition < Declarative::Definitions::Definition
  def getter; end
  def setter; end
end
class Disposable::Twin::Definition::Each < SimpleDelegator
  def each(options = nil); end
end
class Disposable::Twin::Collection < Array
  def <<(model); end
  def added; end
  def append(model); end
  def delete(twin); end
  def deleted; end
  def destroy!; end
  def destroy(twin); end
  def destroyed; end
  def find_by(options); end
  def initialize(twinner, items); end
  def insert(index, model); end
  def original; end
  def save; end
  def self.for_models(twinner, models, *options); end
  def to_destroy; end
  include Disposable::Twin::Collection::Changed
end
module Disposable::Twin::Collection::Changed
  def changed?; end
end
module Disposable::Twin::Collection::Semantics
  def save; end
end
module Disposable::Twin::Sync
  def self.hash_representer(twin_class, &block); end
  def self.included(includer); end
  def sync!(options); end
  def sync(options = nil); end
  def sync_models(options = nil); end
  def sync_read(definition); end
  include Disposable::Twin::Sync::SyncOptions
  include Disposable::Twin::Sync::ToNestedHash
  include Disposable::Twin::Sync::Writeable
end
class Disposable::Twin::Sync::Options < Hash
  def exclude!(names); end
  def excludes; end
end
module Disposable::Twin::Sync::ToNestedHash
  def nested_hash_source; end
  def to_nested_hash(*arg0); end
end
module Disposable::Twin::Sync::ToNestedHash::ClassMethods
  def build_nested_hash_representer; end
  def nested_hash_representer; end
end
module Disposable::Twin::Sync::SyncOptions
  def sync_options(options); end
end
module Disposable::Twin::Sync::Writeable
  def sync_options(options); end
end
module Disposable::Twin::Sync::SkipUnchanged
  def self.included(base); end
  def sync_options(options); end
end
module Disposable::Twin::Sync::SkipGetter
  def nested_hash_source; end
  def sync_read(dfn); end
end
module Disposable::Twin::Save
  def save!(options = nil); end
  def save(options = nil, &block); end
  def save_model; end
end
module Disposable::Twin::Builder
  def self.included(base); end
end
module Disposable::Twin::Changed
  def _changed; end
  def _find_changed_twins!(changes); end
  def changed; end
  def changed?(*args); end
  def initialize(model, *args); end
  def write_property(name, value, dfn); end
end
class Disposable::Twin::Changed::Changes < Hash
  def changed?(name = nil); end
end
class Disposable::Twin::PropertyProcessor
  def call(&block); end
  def collection!; end
  def initialize(definition, twin, value = nil); end
  def property!; end
end
module Disposable::Twin::Persisted
  def created?; end
  def save!(*arg0); end
  def self.included(includer); end
end
module Disposable::Twin::Default
  def default_for(dfn, options); end
  def self.included(includer); end
  def setup_value_for(dfn, options); end
end
module Disposable::Twin::Default::ClassMethods
  def build_definition(name, options = nil, &block); end
end
class Disposable::Twin::InvalidPropertyNameError < StandardError
end
module Disposable::Twin::Accessors
  def build_collection(dfn, *args); end
  def build_for(dfn, *args); end
  def build_twin(dfn, *args); end
  def field_read(name); end
  def field_write(name, value); end
  def write_property(name, value, dfn); end
end
class Disposable::Twin::Twinner
  def call(*args); end
  def initialize(twin, dfn); end
end
module Disposable::Twin::ModelReaders
  def mapper; end
  def model; end
end
class Disposable::Rescheme
  def build_definition!(options, source_dfn, representer, &block); end
  def build_representer(options); end
  def evaluate_block!(options, definition); end
  def exclude!(options, dfn_options); end
  def from(source_class, options, &block); end
  def from_inline!(options, dfn, new_options, representer, &block); end
  def from_scalar!(options, dfn, new_options, representer); end
  def self.from(*args, &block); end
end
class Disposable::Expose
  def initialize(model); end
  def self.accessors!(public_name, private_name, definition); end
  def self.from(schema); end
  def self.process_definition!(definition); end
  include Disposable::Expose::Save
end
module Disposable::Expose::Save
  def save; end
end
class Disposable::Composition < Disposable::Expose
  def [](name); end
  def each(&block); end
  def initialize(models); end
  def self.accessors!(public_name, private_name, definition); end
end
module Disposable::Twin::Expose
  def self.included(base); end
  include Disposable::Twin::Expose::Initialize
end
module Disposable::Twin::Expose::ClassMethods
  def expose_class; end
end
module Disposable::Twin::Expose::Initialize
  def mapper_for(*args); end
end
module Disposable::Twin::Composition
  def save_model; end
  def self.included(base); end
  def to_nested_hash(*arg0); end
end
module Disposable::Twin::Composition::ClassMethods
  def expose_class; end
end
module Disposable::Twin::Coercion
  def self.included(includer); end
end
module Disposable::Twin::Coercion::Types
  extend Anonymous_Dry_Core_Deprecations_Tagged_109
  extend Anonymous_Module_110
  extend Dry::Core::Deprecations::Interface
  extend Dry::Types::BuilderMethods
  include Disposable::Twin::Coercion::Types::DRY_MODULE
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Nominal
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Strict
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Coercible
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Optional
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Optional::Strict
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Optional::Coercible
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Optional::Params
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::Params
end
module Disposable::Twin::Coercion::Types::DRY_MODULE::JSON
end
module Disposable::Twin::Coercion::Types::DRY_MODULE
  def self.included(base); end
  extend Dry::Types::BuilderMethods
end
module Anonymous_Dry_Core_Deprecations_Tagged_109
end
module Anonymous_Module_110
  def const_missing(missing); end
end
module Disposable::Twin::Coercion::ClassMethods
  def coercing_setter!(name, type, nilify = nil); end
  def property(name, options = nil, &block); end
end
