# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/openapi_parser/all/openapi_parser.rbi
#
# openapi_parser-0.14.1

module OpenAPIParser
  def self.file_uri(filepath); end
  def self.load(filepath, config = nil); end
  def self.load_hash(hash, config:, uri:, schema_registry:); end
  def self.load_uri(uri, config:, schema_registry:); end
  def self.parse(schema, config = nil); end
  def self.parse_file(content, extension); end
  def self.parse_json(content); end
  def self.parse_with_filepath(schema, filepath, config = nil); end
  def self.parse_yaml(content); end
end
class OpenAPIParser::Config
  def coerce_value; end
  def datetime_coerce_class; end
  def expand_reference; end
  def initialize(config); end
  def path_params_options; end
  def request_body_options; end
  def request_validator_options; end
  def response_validate_options; end
  def strict_response_validation; end
  def validate_header; end
end
class OpenAPIParser::OpenAPIError < StandardError
  def initialize(reference); end
end
class OpenAPIParser::ValidateError < OpenAPIParser::OpenAPIError
  def initialize(data, type, reference); end
  def message; end
  def self.build_error_result(value, schema); end
end
class OpenAPIParser::NotNullError < OpenAPIParser::OpenAPIError
  def message; end
end
class OpenAPIParser::NotExistRequiredKey < OpenAPIParser::OpenAPIError
  def initialize(keys, reference); end
  def message; end
end
class OpenAPIParser::NotExistPropertyDefinition < OpenAPIParser::OpenAPIError
  def initialize(keys, reference); end
  def message; end
end
class OpenAPIParser::NotExistDiscriminatorMappedSchema < OpenAPIParser::OpenAPIError
  def initialize(mapped_schema_reference, reference); end
  def message; end
end
class OpenAPIParser::NotExistDiscriminatorPropertyName < OpenAPIParser::OpenAPIError
  def initialize(key, value, reference); end
  def message; end
end
class OpenAPIParser::NotOneOf < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::NotAnyOf < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::NotEnumInclude < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::LessThanMinimum < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::LessThanExclusiveMinimum < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::MoreThanMaximum < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::MoreThanExclusiveMaximum < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::InvalidPattern < OpenAPIParser::OpenAPIError
  def initialize(value, pattern, reference, example); end
  def message; end
end
class OpenAPIParser::InvalidEmailFormat < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::InvalidUUIDFormat < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::InvalidDateFormat < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::NotExistStatusCodeDefinition < OpenAPIParser::OpenAPIError
  def message; end
end
class OpenAPIParser::NotExistContentTypeDefinition < OpenAPIParser::OpenAPIError
  def message; end
end
class OpenAPIParser::MoreThanMaxLength < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::LessThanMinLength < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::MoreThanMaxItems < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
class OpenAPIParser::LessThanMinItems < OpenAPIParser::OpenAPIError
  def initialize(value, reference); end
  def message; end
end
module OpenAPIParser::Parser::Value
  def _openapi_attr_values; end
  def openapi_attr_value(name, options = nil); end
  def openapi_attr_values(*names); end
end
module OpenAPIParser::Parser::Object
  def _openapi_attr_objects; end
  def openapi_attr_object(name, klass, options = nil); end
  def openapi_attr_objects(*names, klass); end
end
module OpenAPIParser::Parser::List
  def _openapi_attr_list_objects; end
  def openapi_attr_list_object(name, klass, options = nil); end
end
module OpenAPIParser::Parser::Hash
  def _openapi_attr_hash_objects; end
  def openapi_attr_hash_object(name, klass, options = nil); end
end
module OpenAPIParser::Parser::HashBody
  def _openapi_attr_hash_body_objects; end
  def openapi_attr_hash_body_objects(name, klass, options = nil); end
end
class OpenAPIParser::Parser::Core
  def initialize(target_klass); end
  def target_klass; end
  include OpenAPIParser::Parser::Hash
  include OpenAPIParser::Parser::HashBody
  include OpenAPIParser::Parser::List
  include OpenAPIParser::Parser::Object
  include OpenAPIParser::Parser::Value
end
class OpenAPIParser::SchemaLoader::Base
  def initialize(variable_name, options); end
  def load_data(_target_object, _raw_schema); end
  def schema_key; end
  def variable_name; end
  def variable_set(target, variable_name, data); end
end
class OpenAPIParser::SchemaLoader::Creator < OpenAPIParser::SchemaLoader::Base
  def allow_data_type; end
  def allow_reference; end
  def build_object_reference_from_base(base, names); end
  def build_openapi_object_from_option(target_object, ref, schema); end
  def check_object_schema?(check_schema); end
  def check_reference_schema?(check_schema); end
  def escape_reference(str); end
  def initialize(variable_name, options); end
  def klass; end
end
class OpenAPIParser::SchemaLoader::ValuesLoader < OpenAPIParser::SchemaLoader::Base
  def load_data(target_object, raw_schema); end
end
class OpenAPIParser::SchemaLoader::ListLoader < OpenAPIParser::SchemaLoader::Creator
  def create_attr_list_object(target_object, array_schema); end
  def load_data(target_object, raw_schema); end
  def ref_name_base; end
end
class OpenAPIParser::SchemaLoader::ObjectsLoader < OpenAPIParser::SchemaLoader::Creator
  def create_attr_object(target_object, schema); end
  def load_data(target_object, raw_schema); end
end
class OpenAPIParser::SchemaLoader::HashObjectsLoader < OpenAPIParser::SchemaLoader::Creator
  def create_attr_hash_object(target_object, hash_schema); end
  def load_data(target_object, raw_schema); end
  def ref_name_base; end
end
class OpenAPIParser::SchemaLoader::HashBodyLoader < OpenAPIParser::SchemaLoader::Creator
  def create_hash_body_objects(target_object, raw_schema); end
  def initialize(variable_name, options); end
  def load_data(target_object, raw_schema); end
  def reject_keys; end
end
class OpenAPIParser::SchemaLoader
  def all_loader; end
  def children; end
  def core; end
  def initialize(target_object, core); end
  def load_data; end
  def load_data_by_schema_loader(schema_loader); end
  def register_child(object); end
  def target_object; end
end
module OpenAPIParser::Parser
  def _openapi_all_child_objects; end
  def _update_child_object(old, new); end
  def load_data; end
  def self.included(base); end
end
module OpenAPIParser::Parser::ClassMethods
  def _openapi_attr_hash_body_objects(*args, &block); end
  def _openapi_attr_hash_objects(*args, &block); end
  def _openapi_attr_list_objects(*args, &block); end
  def _openapi_attr_objects(*args, &block); end
  def _openapi_attr_values(*args, &block); end
  def _parser_core; end
  def openapi_attr_hash_body_objects(*args, &block); end
  def openapi_attr_hash_object(*args, &block); end
  def openapi_attr_list_object(*args, &block); end
  def openapi_attr_object(*args, &block); end
  def openapi_attr_objects(*args, &block); end
  def openapi_attr_value(*args, &block); end
  def openapi_attr_values(*args, &block); end
  extend Forwardable
end
module OpenAPIParser::Findable
  def find_object(reference); end
  def find_remote_object(reference); end
  def purge_object_cache; end
end
module OpenAPIParser::Expandable
  def expand_hash_attribute(root, name); end
  def expand_hash_objects(root, attribute_names); end
  def expand_list_objects(root, attribute_names); end
  def expand_object(root, object); end
  def expand_objects(root, attribute_names); end
  def expand_reference(root); end
  def referenced_object(root, reference); end
end
module OpenAPIParser::MediaTypeSelectable
  def select_media_type_from_content(content_type, content); end
end
module OpenAPIParser::ParameterValidatable
  def divided_parameter_hash; end
  def header_parameter_hash; end
  def path_parameter_hash; end
  def query_parameter_hash; end
  def set_parent_path_item(path_item); end
  def validate_header_parameter(headers, object_reference, options); end
  def validate_path_params(path_params, options); end
  def validate_query_parameter(params, object_reference, options); end
  def validate_request_parameter(params, headers, options); end
end
module OpenAPIParser::Schemas
end
class OpenAPIParser::Schemas::Base
  def after_init; end
  def initialize(object_reference, parent, root, raw_schema); end
  def inspect; end
  def object_reference; end
  def parent; end
  def raw_schema; end
  def root; end
  extend OpenAPIParser::Parser::ClassMethods
  include OpenAPIParser::Expandable
  include OpenAPIParser::Findable
  include OpenAPIParser::Parser
end
class OpenAPIParser::Schemas::Discriminator < OpenAPIParser::Schemas::Base
  def mapping; end
  def property_name; end
end
class OpenAPIParser::Schemas::OpenAPI < OpenAPIParser::Schemas::Base
  def components; end
  def initialize(raw_schema, config, uri: nil, schema_registry: nil); end
  def load_another_schema(uri); end
  def openapi; end
  def paths; end
  def request_operation(http_method, request_path); end
  def resolve_uri(uri); end
end
class OpenAPIParser::Schemas::Operation < OpenAPIParser::Schemas::Base
  def deprecated; end
  def description; end
  def operation_id; end
  def parameters; end
  def request_body; end
  def responses; end
  def summary; end
  def tags; end
  def validate_request_body(content_type, params, options); end
  def validate_response(response_body, response_validate_options); end
  include OpenAPIParser::ParameterValidatable
end
class OpenAPIParser::Schemas::Parameter < OpenAPIParser::Schemas::Base
  def allow_empty_value; end
  def allow_reserved; end
  def deprecated; end
  def description; end
  def example; end
  def explode; end
  def in; end
  def name; end
  def required; end
  def schema; end
  def style; end
  def validate_params(params, options); end
end
class OpenAPIParser::Schemas::PathItem < OpenAPIParser::Schemas::Base
  def delete; end
  def description; end
  def get; end
  def head; end
  def operation(method); end
  def options; end
  def parameters; end
  def patch; end
  def post; end
  def put; end
  def set_path_item_to_operation; end
  def summary; end
  def trace; end
end
class OpenAPIParser::Schemas::Paths < OpenAPIParser::Schemas::Base
  def path; end
end
class OpenAPIParser::Schemas::Reference < OpenAPIParser::Schemas::Base
  def ref; end
end
class OpenAPIParser::Schemas::RequestBody < OpenAPIParser::Schemas::Base
  def content; end
  def description; end
  def required; end
  def select_media_type(content_type); end
  def validate_request_body(content_type, params, options); end
  include OpenAPIParser::MediaTypeSelectable
end
class OpenAPIParser::Schemas::Responses < OpenAPIParser::Schemas::Base
  def default; end
  def find_response_object(status_code); end
  def response; end
  def status_code_to_wild_card(status_code); end
  def validate(response_body, response_validate_options); end
end
class OpenAPIParser::Schemas::Response < OpenAPIParser::Schemas::Base
  def content; end
  def description; end
  def headers; end
  def select_media_type(content_type); end
  def validate(response_body, response_validate_options); end
  def validate_header(response_headers); end
  include OpenAPIParser::MediaTypeSelectable
end
class OpenAPIParser::Schemas::MediaType < OpenAPIParser::Schemas::Base
  def schema; end
  def validate_parameter(params, options); end
end
class OpenAPIParser::Schemas::Schema < OpenAPIParser::Schemas::Base
  def additional_properties; end
  def all_of; end
  def any_of; end
  def default; end
  def deprecated; end
  def description; end
  def discriminator; end
  def enum; end
  def example; end
  def exclusiveMaximum; end
  def exclusiveMinimum; end
  def format; end
  def items; end
  def maxItems; end
  def maxLength; end
  def maxProperties; end
  def maximum; end
  def minItems; end
  def minLength; end
  def minProperties; end
  def minimum; end
  def multipleOf; end
  def nullable; end
  def one_of; end
  def pattern; end
  def properties; end
  def read_only; end
  def required; end
  def title; end
  def type; end
  def uniqueItems; end
  def write_only; end
end
class OpenAPIParser::Schemas::Components < OpenAPIParser::Schemas::Base
  def headers; end
  def parameters; end
  def request_bodies; end
  def responses; end
  def schemas; end
end
class OpenAPIParser::Schemas::Header < OpenAPIParser::Schemas::Base
  def allow_empty_value; end
  def allow_reserved; end
  def deprecated; end
  def description; end
  def example; end
  def explode; end
  def required; end
  def schema; end
  def style; end
  def validate(value); end
end
class OpenAPIParser::PathItemFinder
  def different_depth_or_method?(splitted_schema_path, splitted_request_path, path_item, http_method); end
  def extract_params(splitted_request_path, splitted_schema_path); end
  def find_path_and_params(http_method, request_path); end
  def initialize(paths); end
  def matches_directly?(request_path, http_method); end
  def matching_paths_with_params(request_path, http_method); end
  def operation_object(http_method, request_path); end
  def param_name(schema_path_item); end
  def parse_path_parameters(schema_path, request_path); end
  def parse_request_path(http_method, request_path); end
  def path_parameters(schema_path); end
  def path_template?(schema_path_item); end
end
class OpenAPIParser::PathItemFinder::Result
  def initialize(path_item_object, operation_object, original_path, path_params); end
  def operation_object; end
  def original_path; end
  def path_item_object; end
  def path_params; end
end
class OpenAPIParser::RequestOperation
  def config; end
  def http_method; end
  def initialize(http_method, result, config); end
  def operation_object; end
  def original_path; end
  def path_item; end
  def path_params; end
  def self.create(http_method, request_path, path_item_finder, config); end
  def validate_path_params(options = nil); end
  def validate_request_body(content_type, params, options = nil); end
  def validate_request_parameter(params, headers, options = nil); end
  def validate_response_body(response_body, response_validate_options = nil); end
end
class OpenAPIParser::RequestOperation::ValidatableResponseBody
  def content_type; end
  def headers; end
  def initialize(status_code, response_data, headers); end
  def response_data; end
  def status_code; end
end
class OpenAPIParser::SchemaValidator
  def all_of_validator; end
  def any_of_validator; end
  def array_validator; end
  def boolean_validator; end
  def float_validator; end
  def initialize(value, schema, options); end
  def integer_validator; end
  def nil_validator; end
  def object_validator; end
  def one_of_validator; end
  def self.validate(value, schema, options); end
  def string_validator; end
  def unspecified_type_validator; end
  def validate_data; end
  def validate_integer(value, schema); end
  def validate_schema(value, schema, **keyword_args); end
  def validator(value, schema); end
  include OpenAPIParser::SchemaValidator::Validatable
end
class OpenAPIParser::SchemaValidator::Options
  def coerce_value; end
  def datetime_coerce_class; end
  def initialize(coerce_value: nil, datetime_coerce_class: nil, validate_header: nil); end
  def validate_header; end
end
class OpenAPIParser::SchemaValidator::ResponseValidateOptions
  def initialize(strict: nil, validate_header: nil); end
  def strict; end
  def validate_header; end
end
module OpenAPIParser::SchemaValidator::Enumable
  def check_enum_include(value, schema); end
end
module OpenAPIParser::SchemaValidator::MinimumMaximum
  def check_minimum_maximum(value, schema); end
  def validate(value, schema); end
end
class OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(_value, _schema, **_keyword_args); end
  def initialize(validatable, coerce_value); end
  def validatable; end
  def validate_discriminator_schema(discriminator, value, parent_discriminator_schemas: nil); end
end
class OpenAPIParser::SchemaValidator::StringValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **_keyword_args); end
  def coerce_date_time(value, schema); end
  def initialize(validator, coerce_value, datetime_coerce_class); end
  def parse_date_time(value, schema); end
  def pattern_validate(value, schema); end
  def validate_date_format(value, schema); end
  def validate_email_format(value, schema); end
  def validate_max_min_length(value, schema); end
  def validate_uuid_format(value, schema); end
  include OpenAPIParser::SchemaValidator::Enumable
end
class OpenAPIParser::SchemaValidator::IntegerValidator < OpenAPIParser::SchemaValidator::Base
  def coerce(value); end
  def coerce_and_validate(value, schema, **_keyword_args); end
  include OpenAPIParser::SchemaValidator::Enumable
  include OpenAPIParser::SchemaValidator::MinimumMaximum
end
class OpenAPIParser::SchemaValidator::FloatValidator < OpenAPIParser::SchemaValidator::Base
  def coerce(value); end
  def coerce_and_validate(value, schema, **_keyword_args); end
  def coercer_and_validate_numeric(value, schema); end
  include OpenAPIParser::SchemaValidator::Enumable
  include OpenAPIParser::SchemaValidator::MinimumMaximum
end
class OpenAPIParser::SchemaValidator::BooleanValidator < OpenAPIParser::SchemaValidator::Base
  def coerce(value); end
  def coerce_and_validate(value, schema, **_keyword_args); end
  include OpenAPIParser::SchemaValidator::Enumable
end
class OpenAPIParser::SchemaValidator::ObjectValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, parent_all_of: nil, parent_discriminator_schemas: nil, discriminator_property_name: nil); end
end
class OpenAPIParser::SchemaValidator::ArrayValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **_keyword_args); end
  def validate_max_min_items(value, schema); end
end
class OpenAPIParser::SchemaValidator::AnyOfValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **_keyword_args); end
end
class OpenAPIParser::SchemaValidator::AllOfValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **keyword_args); end
end
class OpenAPIParser::SchemaValidator::OneOfValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **_keyword_args); end
end
class OpenAPIParser::SchemaValidator::NilValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, schema, **_keyword_args); end
end
class OpenAPIParser::SchemaValidator::UnspecifiedTypeValidator < OpenAPIParser::SchemaValidator::Base
  def coerce_and_validate(value, _schema, **_keyword_args); end
end
module OpenAPIParser::SchemaValidator::Validatable
  def validate_integer(_value, _schema); end
  def validate_schema(value, schema, **keyword_args); end
end
class OpenAPIParser::ParameterValidator
  def self.convert_key(k, is_header); end
  def self.validate_parameter(parameters_hash, params, object_reference, options, is_header = nil); end
end
class OpenAPIParser::ReferenceExpander
  def self.expand(openapi); end
end
