# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/zip_tricks/all/zip_tricks.rbi
#
# zip_tricks-5.6.0

class ZipTricks::BlockDeflate
  def self.deflate_chunk(bytes, level: nil); end
  def self.deflate_in_blocks(input_io, output_io, level: nil, block_size: nil); end
  def self.deflate_in_blocks_and_terminate(input_io, output_io, level: nil, block_size: nil); end
  def self.write_terminator(output_io); end
end
class ZipTricks::BlockWrite
  def <<(buf); end
  def initialize(&block); end
  def pos=(*_args); end
  def seek(*_args); end
  def to_s(*_args); end
end
class ZipTricks::FileReader::StoredReader
  def eof?; end
  def extract(n_bytes = nil); end
  def initialize(from_io, compressed_data_size); end
end
class ZipTricks::FileReader::InflatingReader
  def eof?; end
  def extract(n_bytes = nil); end
  def initialize(from_io, compressed_data_size); end
end
class ZipTricks::FileReader
  def all_indices_of_substr_in_str(of_substring, in_string); end
  def assert_signature(io, signature_magic_number); end
  def get_compressed_data_offset(io:, local_file_header_offset:); end
  def get_eocd_offset(file_io, zip_file_size); end
  def get_zip64_eocd_location(file_io, eocd_offset); end
  def locate_eocd_signature(in_str); end
  def log; end
  def num_files_and_central_directory_offset(file_io, eocd_offset); end
  def num_files_and_central_directory_offset_zip64(io, zip64_end_of_cdir_location); end
  def parse_out_extra_fields(extra_fields_str); end
  def read_2b(io); end
  def read_4b(io); end
  def read_8b(io); end
  def read_cdir_entry(io); end
  def read_local_file_header(io:); end
  def read_local_headers(entries, io); end
  def read_n(io, n_bytes); end
  def read_zip_straight_ahead(io:); end
  def read_zip_structure(io:, read_local_headers: nil); end
  def seek(io, absolute_pos); end
  def self.read_zip_straight_ahead(**options); end
  def self.read_zip_structure(**options); end
  def skip_ahead_2(io); end
  def skip_ahead_4(io); end
  def skip_ahead_8(io); end
  def skip_ahead_n(io, n); end
end
class ZipTricks::FileReader::ReadError < StandardError
end
class ZipTricks::FileReader::UnsupportedFeature < StandardError
end
class ZipTricks::FileReader::InvalidStructure < ZipTricks::FileReader::ReadError
end
class ZipTricks::FileReader::LocalHeaderPending < StandardError
  def message; end
end
class ZipTricks::FileReader::MissingEOCD < StandardError
  def message; end
end
class ZipTricks::FileReader::ZipEntry
  def comment; end
  def comment=(arg0); end
  def compressed_data_offset; end
  def compressed_data_offset=(offset); end
  def compressed_size; end
  def compressed_size=(arg0); end
  def crc32; end
  def crc32=(arg0); end
  def disk_number_start; end
  def disk_number_start=(arg0); end
  def dos_date; end
  def dos_date=(arg0); end
  def dos_time; end
  def dos_time=(arg0); end
  def external_attrs; end
  def external_attrs=(arg0); end
  def extractor_from(from_io); end
  def filename; end
  def filename=(arg0); end
  def gp_flags; end
  def gp_flags=(arg0); end
  def internal_attrs; end
  def internal_attrs=(arg0); end
  def known_offset?; end
  def local_file_header_offset; end
  def local_file_header_offset=(arg0); end
  def made_by; end
  def made_by=(arg0); end
  def storage_mode; end
  def storage_mode=(arg0); end
  def uncompressed_size; end
  def uncompressed_size=(arg0); end
  def uses_data_descriptor?; end
  def version_needed_to_extract; end
  def version_needed_to_extract=(arg0); end
end
module ZipTricks::NullWriter
  def self.<<(_); end
end
class ZipTricks::OutputEnumerator
  def each; end
  def initialize(write_buffer_size: nil, **streamer_options, &blk); end
end
class ZipTricks::PathSet
  def add_directory_path(path); end
  def add_file_path(file_path); end
  def clear; end
  def include?(path_in_archive); end
  def initialize; end
  def non_empty_path_components(path); end
  def path_and_ancestors(path); end
end
class ZipTricks::PathSet::Conflict < StandardError
end
class ZipTricks::PathSet::FileClobbersDirectory < ZipTricks::PathSet::Conflict
end
class ZipTricks::PathSet::DirectoryClobbersFile < ZipTricks::PathSet::Conflict
end
class ZipTricks::RackBody < ZipTricks::OutputEnumerator
end
module ZipTricks::RailsStreaming
  def zip_tricks_stream(**zip_streamer_options, &zip_streaming_blk); end
end
class ZipTricks::RemoteIO
  def clamp(a, b, c); end
  def initialize(url); end
  def read(n_bytes = nil); end
  def request_object_size; end
  def request_range(range); end
  def seek(offset, mode = nil); end
  def size; end
  def tell; end
end
module ZipTricks::RemoteUncap
  def self.files_within_zip_at(uri, reader_class: nil, **options_for_zip_reader); end
end
class ZipTricks::Streamer::DeflatedWriter
  def <<(data); end
  def finish; end
  def initialize(io); end
end
class ZipTricks::Streamer::Writable
  def <<(d); end
  def close; end
  def initialize(streamer, writer); end
  def write(d); end
end
class ZipTricks::Streamer::StoredWriter
  def <<(data); end
  def finish; end
  def initialize(io); end
end
class Anonymous_Struct_93 < Struct
  def bytes_used_for_data_descriptor; end
  def bytes_used_for_data_descriptor=(_); end
  def bytes_used_for_local_header; end
  def bytes_used_for_local_header=(_); end
  def compressed_size; end
  def compressed_size=(_); end
  def crc32; end
  def crc32=(_); end
  def filename; end
  def filename=(_); end
  def local_header_offset; end
  def local_header_offset=(_); end
  def mtime; end
  def mtime=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def storage_mode; end
  def storage_mode=(_); end
  def uncompressed_size; end
  def uncompressed_size=(_); end
  def unix_permissions; end
  def unix_permissions=(_); end
  def use_data_descriptor; end
  def use_data_descriptor=(_); end
end
class ZipTricks::Streamer::Entry < Anonymous_Struct_93
  def gp_flags; end
  def initialize(*arg0); end
  def total_bytes_used; end
end
class ZipTricks::Streamer
  def <<(binary_data); end
  def add_deflated_entry(filename:, modification_time: nil, compressed_size: nil, uncompressed_size: nil, crc32: nil, unix_permissions: nil, use_data_descriptor: nil); end
  def add_empty_directory(dirname:, modification_time: nil, unix_permissions: nil); end
  def add_file_and_write_local_header(filename:, modification_time:, crc32:, storage_mode:, compressed_size:, uncompressed_size:, use_data_descriptor:, unix_permissions:); end
  def add_stored_entry(filename:, modification_time: nil, size: nil, crc32: nil, unix_permissions: nil, use_data_descriptor: nil); end
  def close; end
  def create_writer; end
  def initialize(writable, writer: nil, auto_rename_duplicate_filenames: nil); end
  def remove_backslash(filename); end
  def self.open(stream, **kwargs_for_new); end
  def self.output_enum(**kwargs_for_new, &zip_streamer_block); end
  def simulate_write(num_bytes); end
  def update_last_entry_and_write_data_descriptor(crc32:, compressed_size:, uncompressed_size:); end
  def verify_offsets!; end
  def write(binary_data); end
  def write_deflated_file(filename, modification_time: nil, unix_permissions: nil); end
  def write_stored_file(filename, modification_time: nil, unix_permissions: nil); end
end
class ZipTricks::Streamer::EntryBodySizeMismatch < StandardError
end
class ZipTricks::Streamer::InvalidOutput < ArgumentError
end
class ZipTricks::Streamer::Overflow < StandardError
end
class ZipTricks::Streamer::UnknownMode < StandardError
end
class ZipTricks::Streamer::OffsetOutOfSync < StandardError
end
class ZipTricks::SizeEstimator
  def add_deflated_entry(filename:, uncompressed_size:, compressed_size:, use_data_descriptor: nil); end
  def add_empty_directory_entry(dirname:); end
  def add_stored_entry(filename:, size:, use_data_descriptor: nil); end
  def initialize(streamer); end
  def self.estimate(**kwargs_for_streamer_new); end
end
class ZipTricks::StreamCRC32
  def <<(blob); end
  def append(crc32, blob_size); end
  def initialize; end
  def self.from_io(io); end
  def to_i; end
end
module ZipTricks::UniquifyFilename
  def self.call(path, while_included_in); end
end
module ZipTricks
end
class ZipTricks::WriteAndTell
  def <<(bytes); end
  def advance_position_by(num_bytes); end
  def initialize(io); end
  def tell; end
end
class ZipTricks::WriteBuffer
  def <<(data); end
  def flush!; end
  def flush; end
  def initialize(writable, buffer_size); end
end
class ZipTricks::ZipWriter
  def generate_external_attrs(unix_permissions_int, file_type_int); end
  def pack_array(values_to_packspecs); end
  def timestamp_extra_for_central_directory_entry(mtime); end
  def timestamp_extra_for_local_file_header(mtime); end
  def to_binary_dos_date(t); end
  def to_binary_dos_time(t); end
  def write_central_directory_file_header(io:, local_file_header_location:, gp_flags:, storage_mode:, compressed_size:, uncompressed_size:, mtime:, crc32:, filename:, unix_permissions: nil); end
  def write_data_descriptor(io:, compressed_size:, uncompressed_size:, crc32:); end
  def write_end_of_central_directory(io:, start_of_central_directory_location:, central_directory_size:, num_files_in_archive:, comment: nil); end
  def write_local_file_header(io:, filename:, compressed_size:, uncompressed_size:, crc32:, gp_flags:, mtime:, storage_mode:); end
  def zip_64_extra_for_central_directory_file_header(compressed_size:, uncompressed_size:, local_file_header_location:); end
  def zip_64_extra_for_local_file_header(compressed_size:, uncompressed_size:); end
end
